"""GitHub client for creating schema documentation PRs."""

from __future__ import annotations

import json
from dataclasses import dataclass
from datetime import datetime
from typing import Any

from github import Auth, Github
from github.Repository import Repository


@dataclass
class SchemaUpdate:
    """Represents an update to a schema file."""

    file_path: str
    original_schema: dict[str, Any]
    updated_schema: dict[str, Any]
    changes_summary: list[str]


class GitHubClient:
    """Client for creating PRs with schema documentation updates."""

    def __init__(self, token: str, repo_name: str):
        """
        Initialize GitHub client.

        Args:
            token: GitHub personal access token
            repo_name: Repository in format "owner/repo"
        """
        self.github = Github(auth=Auth.Token(token))
        self.repo: Repository = self.github.get_repo(repo_name)

    def create_documentation_pr(
        self,
        schema_updates: list[SchemaUpdate],
        base_branch: str = "main",
        dry_run: bool = False,
    ) -> str | None:
        """
        Create a PR with schema documentation updates.

        Args:
            schema_updates: List of schema updates to apply
            base_branch: Base branch for the PR
            dry_run: If True, don't actually create the PR

        Returns:
            PR URL if created, None if dry_run
        """
        if not schema_updates:
            return None

        # Generate branch name
        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        branch_name = f"schema-doc-agent/metadata-update-{timestamp}"

        if dry_run:
            print(f"\n[DRY RUN] Would create branch: {branch_name}")
            for update in schema_updates:
                print(f"  - Would update: {update.file_path}")
                for change in update.changes_summary:
                    print(f"    â€¢ {change}")
            return None

        # Get base branch ref
        base_ref = self.repo.get_branch(base_branch)

        # Create new branch
        self.repo.create_git_ref(
            ref=f"refs/heads/{branch_name}",
            sha=base_ref.commit.sha,
        )

        # Apply updates to files
        for update in schema_updates:
            self._update_file(
                file_path=update.file_path,
                content=json.dumps(update.updated_schema, indent=2),
                branch=branch_name,
                message=f"docs: add documentation to {update.file_path}",
            )

        # Create pull request
        pr_title = f"docs: Auto-generated schema documentation ({len(schema_updates)} schemas)"
        pr_body = self._generate_pr_body(schema_updates)

        pr = self.repo.create_pull(
            title=pr_title,
            body=pr_body,
            head=branch_name,
            base=base_branch,
        )

        return pr.html_url

    def _update_file(
        self,
        file_path: str,
        content: str,
        branch: str,
        message: str,
    ) -> None:
        """Update or create a file in the repository."""
        try:
            # Try to get existing file
            existing = self.repo.get_contents(file_path, ref=branch)
            if isinstance(existing, list):
                existing = existing[0]
            self.repo.update_file(
                path=file_path,
                message=message,
                content=content,
                sha=existing.sha,
                branch=branch,
            )
        except Exception:
            # File doesn't exist, create it
            self.repo.create_file(
                path=file_path,
                message=message,
                content=content,
                branch=branch,
            )

    def _generate_pr_body(self, schema_updates: list[SchemaUpdate]) -> str:
        """Generate a detailed PR description."""
        total_changes = sum(len(u.changes_summary) for u in schema_updates)

        body = f"""## ðŸ¤– Schema Documentation Update

This PR was automatically generated by **Schema Documentation Agent** to add missing documentation to schemas.

### Summary
- **Schemas Updated:** {len(schema_updates)}
- **Documentation Added:** {total_changes} fields/records

### Changes by Schema

"""
        for update in schema_updates:
            body += f"#### `{update.file_path}`\n"
            for change in update.changes_summary[:10]:  # Limit to first 10
                body += f"- {change}\n"
            if len(update.changes_summary) > 10:
                body += f"- ... and {len(update.changes_summary) - 10} more\n"
            body += "\n"

        body += """---

### Review Notes
- All documentation was generated using AI and should be reviewed for accuracy
- Fields marked with **LOW** confidence may need manual adjustment
- This PR only adds `doc` fields and does not change schema structure

*Generated by [Schema Documentation Agent](https://github.com/akrishnanDG/schema-doc-agent)*
"""
        return body

    def find_schema_files(
        self,
        path: str = "",
        extension: str = ".avsc",
        include_patterns: list[str] | None = None,
        exclude_patterns: list[str] | None = None,
    ) -> list[tuple[str, dict[str, Any]]]:
        """
        Find all schema files in the repository.

        Args:
            path: Path to search (empty for root)
            extension: File extension to look for
            include_patterns: Glob patterns for files to include (None = all)
            exclude_patterns: Glob patterns for files to exclude

        Returns:
            List of (file_path, schema_dict) tuples
        """
        from .config import filter_subjects
        
        schemas: list[tuple[str, dict[str, Any]]] = []
        self._search_directory(path, extension, schemas)
        
        # Apply filters if specified
        if include_patterns or exclude_patterns:
            filtered = []
            file_paths = [fp for fp, _ in schemas]
            matching_paths = filter_subjects(
                file_paths,
                include_patterns or [],
                exclude_patterns or [],
            )
            matching_set = set(matching_paths)
            filtered = [(fp, schema) for fp, schema in schemas if fp in matching_set]
            return filtered
        
        return schemas

    def _search_directory(
        self,
        path: str,
        extension: str,
        results: list[tuple[str, dict[str, Any]]],
    ) -> None:
        """Recursively search for schema files."""
        try:
            contents = self.repo.get_contents(path)
            if not isinstance(contents, list):
                contents = [contents]

            for content in contents:
                if content.type == "dir":
                    self._search_directory(content.path, extension, results)
                elif content.name.endswith(extension):
                    try:
                        file_content = content.decoded_content.decode("utf-8")
                        schema = json.loads(file_content)
                        results.append((content.path, schema))
                    except (json.JSONDecodeError, UnicodeDecodeError) as e:
                        print(f"Warning: Could not parse {content.path}: {e}")
        except Exception as e:
            print(f"Warning: Could not access {path}: {e}")

